让客户端和子系统的总的各个模块结构，使客户端更容易地使用系统

特点
    多个模块
    对多个模块调用过程的封装
门面模式的优点
　　门面模式的优点：
    松散耦合
    门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。
    简单易用
　　门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。
    更好的划分访问层次
    通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节。

应用场景
1、为子系统中的一组接口提供统一的接口，让客户端更容易去使用
    Tomcat的HttpRequestFacade封装了HttpRequest
2、使用门面模式还有一个附带的好处，就是能够有选择性地暴露方法。一个模块中定义的方法可以分成两部分，
    一部分是给子系统外部使用的，一部分是子系统内部模块之间相互调用时使用的。
    有了Facade类，那么用于子系统内部模块之间相互调用的方法就不用暴露给子系统外部了。
    -->service负责和各个dao打交道，可以说service是controller的门面

六、需要注意的几点

一个系统有多个外观类
    在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个单例类。
    在很多情况下为了节约系统资源，一般将外观类设计为单例类。当然这并不意味着在整个系统里只能有一个外观类，
    在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互，向用户提供相应的业务功能。
不要试图通过外观类为子系统增加新行为
    不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。
    外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，
    新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现。
外观模式与迪米特法则
    外观模式创造出一个外观对象，将客户端所涉及的属于一个子系统的协作伙伴的数量减到最少，
    使得客户端与子系统内部的对象的相互作用被外观对象所取代。外观类充当了客户类与子系统类之间的“第三者”，降低了客户类与子系统类之间的耦合度，
       外观模式就是实现代码重构以便达到“迪米特法则”要求的一个强有力的武器。
抽象外观类的引入
    外观模式最大的缺点在于违背了“开闭原则”，当增加新的子系统或者移除子系统时需要修改外观类，
    可以通过引入抽象外观类在一定程度上解决该问题，客户端针对抽象外观类进行编程。
    对于新的业务需求，不修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改源代码并更换外观类的目的。